System overview and purpose
- This FreeRTOS task (Else_Task) runs on an embedded controller that drives a motorized door/actuator using yaw (angular) feedback from an IMU. It accepts LoRa and Bluetooth commands, reacts to physical push/pull detection, enforces mechanical/angle limits, and manages low-power sleep/wake behavior.
- The system combines:
  - Command parsing (LoRa, Bluetooth) to open/close and configure speed/angle.
  - Closed-loop motor control with yaw feedback and stall/oscillation detection for safety.
  - A calibration/limit procedure (Auto_Check) whose results are persisted to flash.
  - Power management: motor power gating, IMU/Radar sleep, and BLE link management.

High-level pipeline (inputs to outputs)
1. Startup:
   - Initialize comm flags, stop the motor, recover configuration from flash (diff_sumup angle limit, check_flag calibration state).
2. Main loop (periodic):
   - Poll current, check Bluetooth commands, and handle LoRa frames.
   - If not yet calibrated (check_flag == false), any LoRa frame triggers Auto_Check.
   - If calibrated (check_flag == true), the task:
     - Handles idle timeout to enter low power or auto-close.
     - Parses LoRa command “AA..” variants to select speed/angle, close, or reset to calibration.
     - Decides to run the motor forward (open) or reverse (close) based on:
       - Command-driven flags (commandExecuted, commandExecuted_r).
       - Physical push/pull flags (ahead_flag, back_flag).
       - A local PB6 edge-triggered wake/actuation.
     - Drives the motor in speed mode toward a yaw threshold; monitors progress and safety via Yaw_Stall_Check.
     - Stops and optionally transitions to reverse close, then sleeps the platform.
   - Independently, if AA00 “keep power” is active, maintain motor power unless it times out and no movement is ongoing.
3. Outputs:
   - Motor command packets and motor power enable.
   - System sleep of IMUs, radar, BLE link teardown, and low-power flagging.
   - Persistent updates: angle/range thresholds and calibration state stored to flash (some writes are performed elsewhere; here we read and act on them).

Key notions and data
- yaw: current angle reading. diff_sumup: an angle limit/target (restored from flash after calibration).
- Speed_from_Lora: speed ceiling from LoRa, set by a level (600/1200/2000).
- Angle_Level_Lora: controls how far to open relative to the saved limit (1/3, 1/2, or full).
- Flags:
  - check_flag: calibration completed; determines whether to accept control commands or run Auto_Check.
  - motor_runing_flag (forward) and motor_runing_flag_r (reverse): active movement states.
  - commandExecuted / commandExecuted_r: “start motion” latches from commands.
  - ahead_flag / back_flag: physical push/pull triggers from sensors.
  - aa00_motor_enabled + last_message_time: “AA00 keep-power” gating.
  - close_flag and closing_inpurrt: control transition to reverse (close) and coordination between phases.

Initialization and persisted data
- On task start:
  - lora_rx_flag = 0 and rpm0_Stop().
  - Load two values from flash via Flash_Storage_Read: diff_sumup (angle limit) and check_flag (calibration status). If OK, these globals are restored.
  - If check_flag is true (calibrated), motor driver power (SIGNAL_ENABLE) is set low (disabled) initially.

Main loop phases and branches
- Common operations on each cycle:
  - Read bus current snapshot (Motor_TryReadBusCurrent).
  - Parse Bluetooth commands: XY_MB06BA_CheckAndParseCommands().
  - If not calibrated (check_flag == false):
    - Any LoRa frame (lora_rx_flag) triggers Auto_Check(), clears the LoRa buffer, and refreshes Wake_time. This branch exits early and skips motion logic.
  - If calibrated (check_flag == true):
    - Idle/sleep management:
      - If 15 s have elapsed since Wake_time and |yaw| < 10° (i.e., door closed), then:
        - Disable motor power.
        - Sequence BLE disconnections, IMU sleep (JY61P/LSM6DSV16X), update radar threshold, set low-power flag.
        - Remain in low power (delays are inserted).
      - Else if 15 s elapsed but |yaw| ≥ 10° (door not closed):
        - Refresh Wake_time and set motor_runing_flag_r = 1 to initiate closing automatically.
    - LoRa frame parsing (lora_rx_flag set):
      - AAx y commands are parsed only if the first two bytes are ‘A’‘A’.
      - AA00:
        - Set motor driver power enable pin high (on).
        - Set aa00_motor_enabled = true and record last_message_time.
        - Important: The earlier “open control” kick phase is intentionally removed; AA00 now only maintains power.
      - AAxy (x = speed_char, y = angle_char):
        - Speed level: if x in ‘1’..‘3’:
          - Set Speed_Level_Lora = x - '0', face_control_flag = 1.
          - Latch commandExecuted = true and motor_runing_flag = 1 (start forward/open), set closing_inpurrt = 1 (enables a subsequent close transition).
        - Angle level: if y in ‘1’..‘3’: Angle_Level_Lora = y - '0'.
        - Speed cap selection:
          - Level 1 => 600
          - Level 2 => 1200
          - Level 3 => 2000
          - Default => 1500
        - Special letter combos:
          - ‘OF’: sets close_flag = 1 (request a close after current forward cycle).
          - ‘RE’: sets check_flag = 0 (returns to calibration/limit procedure on next LoRa frame).
      - After parsing, clear lora_rx_buf and lora_rx_flag.
    - Forward/open motion branch
      - Entry conditions:
        - ((commandExecuted || ahead_flag) && |diff_sumup - yaw| > 2 && yaw < diff_sumup) OR motor_runing_flag == 1.
      - On first entry (Motor_Init == 0):
        - Enable motor power, record move_start, reset bus current accumulator, mark stall detection uninitialized, and set Motor_Init = 1.
      - Compute target threshold:
        - angle_divisor by angle level: 3.0 (min), 2.0 (mid), 1.0 (max).
        - threshold = diff_sumup / angle_divisor, unless face_control_flag == 0, in which case threshold = diff_sumup (use full range).
      - Speed control setup:
        - send_data(speed_control) is sent once per run to put the motor into speed mode.
      - Compute speed command:
        - speed = Motor_P * (threshold - yaw), clipped to ±Speed_from_Lora. Motor_P = 40.
        - Send via motor_drive_cmd(0x01, speed, 20, 0, motor_cmd).
      - Stop conditions (any true):
        - |threshold - yaw| < 5° OR |diff_sumup - yaw| < 5° OR Yaw_Stall_Check() returns true OR yaw > diff_sumup.
      - On stop:
        - rpm0_Stop(); clear run flags and one-shot init flags; disable motor power.
        - Clear commandExecuted, ahead/back flags, reset face_control_flag, and related latched flags.
        - If close_flag == 1 (from an ‘OF’ command), prepare to reverse:
          - commandExecuted_r = 1 and motor_runing_flag_r = 1, close_flag = 0.
        - If close_flag != 1: remain idle; if AA00 is active the motor power may be independently held by AA00 logic (see below).
      - Else branch (no forward move):
        - Ensure flags cleared; if close_flag == 1, enqueue a reverse move as above.
    - Reverse/close motion branch
      - Entry conditions:
        - ((commandExecuted_r || back_flag) && |yaw| > 2 && yaw > 0) OR motor_runing_flag_r == 1.
      - On first entry (Motor_Init_r == 0):
        - Enable motor power, record move_start, reset current accumulator, mark stall detection uninitialized, set Motor_Init_r = 1.
      - Threshold is 0 degrees; speed setup is sent once.
      - Compute speed:
        - speed = Motor_P * (0 - (yaw + 3)), i.e., bias 3° toward closing, clipped to ±Speed_from_Lora.
        - Send via motor_drive_cmd.
      - Stop conditions:
        - |yaw| < 5° OR Yaw_Stall_Check() indicates collision/abnormality OR yaw < 0° OR closing_inpurrt == 1.
      - On stop:
        - If neither collision nor closing_inpurrt occurred:
          - Brief retraction: command -1000 speed for 1 s to relieve mechanical stress.
          - Disable motor power, clear all flags, and enter low power:
            - Toggle BLE disconnect, sleep IMUs, set radar distance (512) and low power flag, then loop until JY61P yaw reset succeeds.
        - If closing_inpurrt == 1 (chaining from a forward cycle):
          - Arm a new forward cycle: set motor_runing_flag = 1 and clear Motor_Init to re-enter forward init on next loop; clear closing_inpurrt.
      - Else branch (no reverse move): clear reverse flags and inits.
    - AA00 “keep-power” management (independent of motion):
      - When aa00_motor_enabled == true:
        - If moving (forward or reverse or physical flags are active), refresh last_message_time (prevents timeout).
        - If not moving and now - last_message_time > MESSAGE_TIMEOUT_MS, then disable motor power and clear aa00_motor_enabled.
        - Note: MESSAGE_TIMEOUT_MS is defined as 100 (ms) but the comment says “10s”. This mismatch likely causes much shorter timeouts than intended.
    - PB6 edge-triggered wake/actuation:
      - If a rising or falling edge is detected on PB6 and no motion is active, increment a debounced counter; upon count ≥ 1, reset it and set motor_runing_flag = 1 (kick off a forward movement).
    - Periodic delay: osDelay(10) bounds the loop at ~100 Hz.

Command set and triggers (explicit branches)
- LoRa “AA..” commands:
  - AA00: Maintain motor power on. Repeated AA00 frames reset the timeout. No motion is started by this command.
  - AAxy:
    - x in ‘1’, ‘2’, ‘3’: set Speed_Level_Lora and cap (600, 1200, 2000); also set face_control_flag and trigger forward/open (commandExecuted = 1; motor_runing_flag = 1).
    - y in ‘1’, ‘2’, ‘3’: set Angle_Level_Lora (open target = 1/3, 1/2, or full diff_sumup).
    - Special cases of x,y:
      - ‘OF’: set close_flag (request a closing pass after the forward cycle stops).
      - ‘RE’: set check_flag = 0 to re-enter calibration mode on the next LoRa reception.
- Physical triggers:
  - ahead_flag == true: behaves like a forward/open request.
  - back_flag == true: behaves like a reverse/close request.
  - PB6 GPIO rising/falling edge: if idle, triggers forward/open (motor_runing_flag = 1).
- Automatic transitions:
  - Idle >15 s and |yaw| < 10°: enter low-power sleep.
  - Idle >15 s and |yaw| ≥ 10°: auto-start reverse/close (motor_runing_flag_r = 1).
  - Forward stop with close_flag set: transition into reverse/close.
  - Reverse stop without collision and not chaining: enter low-power sleep with yaw reset.
  - Reverse stop due to closing_inpurrt: chain back to forward.

Motor control specifics
- Control mode: speed loop. A one-time speed_control packet is sent at each movement start; subsequent updates are via motor_drive_cmd.
- Forward/open law: speed = 40 * (threshold - yaw), saturated by Speed_from_Lora.
- Reverse/close law: speed = 40 * (0 - (yaw + 3)), saturated by Speed_from_Lora.
- Stop thresholds:
  - Forward: near-threshold within 5°, or global limit within 5°, or stall/oscillation detected, or overshoot beyond diff_sumup.
  - Reverse: |yaw| < 5°, stall/oscillation, or yaw < 0°, or “closing_inpurrt” chaining condition.
- Safety/stall detection via Yaw_Stall_Check (see below).

Yaw_Stall_Check function (safety)
- Purpose: Detects if yaw is not progressing, oscillating, or moving in the wrong direction.
- Debounce: ignores the first 1.5 s after move_start.
- On first call per movement (stall_check_initialized == false), initializes references and returns false.
- Checks performed on each call:
  - Wrong-direction movement:
    - If forward (motor_runing_flag == 1) and |yaw| decreases (beyond 0.01°), increment motion_direction_error_count.
    - If reverse (motor_runing_flag_r == 1) and |yaw| increases (beyond 0.01°), increment count.
    - If count ≥ 1, declare stall_detected = true and reset the detector state; return true.
  - Oscillation:
    - Track successive increments (yaw - last_yaw). If the sign flips twice (direction_change_count ≥ 2) with meaningful deltas (>0.01°), declare stall and return true.
  - Lack of progress (stagnation):
    - Maintain yaw_stall_check_start and a timer. If |yaw - start| > 0.1°, reset window and continue.
    - Else if elapsed ≥ 1.5 s and |yaw - start| ≤ 0.1°, declare stall.
- On any detection, the function resets its internal state to ensure a fresh check on the next movement phase.

Power management and sleep sequence
- Triggered by:
  - Idle >15 s with yaw small in the main loop; or
  - Reverse motion completion without collision and not in a chaining close/open; or
  - AA00 timeout with no movement (only disables motor power, not full sleep).
- Actions:
  - Disable motor power (SIGNAL_ENABLE low).
  - Toggle BLE link disconnects via AT, sleep the JY61P IMU UART and LSM6DSV16X, set radar distance threshold to 512 (FRadar_SetDistanceAndSave), and set LowPower sleep flag.
  - On reverse completion sleep, loop until JY61P yaw reset succeeds.

External integrations and storage
- LoRa: lora_rx_buf/lora_rx_flag, subtle command parsing limited to “AA..”; earlier commands mentioned in comments (e.g., 2128/2222/1515) are not in the active parsing branch.
- Bluetooth: XY_MB06BA_CheckAndParseCommands processes BLE commands; AT commands used to force disconnects. Details of accepted BLE commands are not shown here.
- IMUs:
  - JY61P (UART) for yaw and sleep/reset control.
  - LSM6DSV16X for inertial data; put to sleep for low power.
- Radar: FRadar_SetDistanceAndSave(&s_fradar, 512) sets a distance threshold and persists it internally (non-volatile).
- Flash: Flash_Storage_Read restores diff_sumup and check_flag; writing is done elsewhere (e.g., Auto_Check and radar functions). There is also a gyro_calib_storage include, implying yaw calibration offset persistence, though not used directly here.
- Motor driver:
  - SIGNAL_ENABLE pin gates power.
  - send_data(speed_control) selects speed control mode.
  - motor_drive_cmd issues speed commands.
  - rpm0_Stop stops motion.
  - g_motor_bus_current_A used as a running current metric, reset at movement start.
- GPIO PB6: Edge-detected wake using GPIO_CheckEdge with debouncing.

Assumptions, limits, and notes
- check_flag semantics: false means “not calibrated”; first subsequent LoRa frame triggers Auto_Check(). After calibration, control logic is enabled. Actual Auto_Check implementation and how it sets diff_sumup/check_flag are outside this file.
- AA00 timeout mismatch: MESSAGE_TIMEOUT_MS is set to 100 (ms), while the comment claims 10 s. If 10 s is intended, this constant should be increased (e.g., 10000).
- Safety thresholds:
  - Stop bands use 5°; oscillation and stagnation use very small deltas (0.01° and 0.1° windows). Ensure yaw units are degrees and sensor noise permits these thresholds.
- Reverse bias: A +3° bias is added in reverse control law to ensure firm closure; combined with the |yaw|<5° stop band, this may cause a brief “push” then retract logic (-1000, 1s) if no collision/stall is detected.
- Face-control vs. full-open:
  - face_control_flag = 1 when AAxy sets speed level via numeric x; threshold is a fraction of diff_sumup per angle level.
  - If face_control_flag = 0, the system targets full diff_sumup regardless of Angle_Level_Lora.
- Low-power entry conditions appear in multiple places (idle and reverse completion). The BLE disconnect sequence sends multiple toggled commands; this likely ensures link drop across modes.
- Physical triggers (ahead_flag/back_flag) and PB6 edges act as immediate start cues; their source modules and debouncing for ahead/back are not shown here.
- Error handling: The task uses conservative stop conditions (stall/oscillation, overshoot bounds, time-based stasis) rather than explicit fault codes. Movement init and stall detection state are carefully reset at each phase transition.
- Concurrency: This is a single FreeRTOS task controlling state. Shared globals (yaw, flags) are assumed to be updated by ISRs or other tasks; no explicit synchronization is used here, so variable volatility and update timing must be considered.

State machine summary
- Calibration mode (check_flag = false):
  - On any LoRa frame: Auto_Check; upon completion, flash is updated (outside this file), then transitions to Operational.
- Operational mode (check_flag = true):
  - Idle (power may be off unless AA00 holds it):
    - Triggers: AAxy (numeric) or ahead_flag → ForwardMove; back_flag or auto-close → ReverseMove; PB6 edge → ForwardMove; AA00 → KeepPower.
    - Idle >15 s with yaw<10° → Sleep.
    - Idle >15 s with yaw≥10° → ReverseMove (auto-close).
  - ForwardMove:
    - Drives toward yaw threshold (fraction of diff_sumup). On stop:
      - If close_flag set → ReverseMove.
      - Else → Idle (or Sleep if idle timer later fires).
  - ReverseMove:
    - Drives toward 0°. On stop:
      - If no collision and not chaining → Sleep.
      - If chaining (closing_inpurrt) → ForwardMove.
  - KeepPower (AA00):
    - Independent overlay: keeps SIGNAL_ENABLE high while frames arrive or until timeout when idle.

This walkthrough is designed so a flowchart generator can create:
- Nodes for initialization, calibration, idle, AA00 overlay, forward motion, reverse motion, sleep.
- Edges labeled by the triggers: LoRa AA00, AAxy [1..3]/[1..3], ‘OF’, ‘RE’, ahead_flag, back_flag, PB6 edge, idle timeouts, stall detection, position thresholds, and closing_inpurrt chaining.