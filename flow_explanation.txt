**System overview and context**

This firmware runs on an STM32L431-based door-control unit that combines face-recognition, radar/LiDAR sensing, and remote communications (LoRa and Bluetooth) to manage door opening behaviour. A small OLED display and three physical keys provide local interaction. The code you supplied focuses on the “Flash task” thread that supervises user interaction, menu navigation, persistent storage of user-specific door parameters, and integration with other subsystems (battery monitoring, PIR sensor, LoRa, Bluetooth, radar calibration, face recognition). Device state is tracked through a global `system_state` enum, and most logic pivots on state transitions triggered by button events, sensor inputs, or external commands.

**High-level flow from inputs to outputs**

1. **Inputs collected continually**
   - Three hardware keys (short press, long press).
   - Battery sensor readings.
   - PIR motion sensor.
   - LoRa “lora_rx_flag” indicator from radio stack.
   - Face-recognition success/fail callbacks (through global flags).
   - Bluetooth/XY-MB06BA module connection feedback.
2. **Event processing**
   - Key events are debounced and queued; UI logic pulls from a queue-like interface, making the code safe for polling or interrupt-driven key scanning.
   - The FreeRTOS `Flash_Task` loops forever, checking `system_state` and delegating to menu handlers or service routines accordingly.
3. **State-driven actions**
   - If idle, the system waits for user input, shows minimal UI, and can drop into low-power mode.
   - Menu states render OLED screens, accept user choices, and call specific handlers (configuration, delete, do-not-disturb, door reset).
   - Face enrolment / deletion states present progress bars and status messages, using radar/face modules to complete operations.
   - Do-not-disturb state suppresses outputs and listens for an exit key press or PIR motion triggers.
4. **Outputs**
   - OLED feedback (menus, progress bars, status prompts).
   - Flash memory updates for user configuration or BLE MAC address.
   - UART/HC15 Bluetooth module messages (diagnostic strings such as `AA0055`, `AARE55`, etc.).
   - XY-MB06BA module AT commands to manage Bluetooth disconnection.
   - LoRa responses (`AARI55`, `AARF55`) when packets arrive.
   - GPIO control for power management (e.g., NMOS gate, door actuators).

---

### Core subsystems and their responsibilities

#### 1. State machine and main FreeRTOS task (`Flash_Task`)
- Runs continually, switching behaviour based on `system_state`.
- Handles side chores every loop: LoRa message acknowledgement, low-power entry, drawing blank screens.
- Key states and actions:
  - **`SYSTEM_IDLE`**: waits two seconds before initiating low-power mode (Bluetooth disconnect commands, turning off display, powering down NMOS). Keeps clearing the display.
  - **`MENU_ACTIVE`**: launches the top-level menu (see below), then depending on selection, returns to idle unless Do Not Disturb was activated.
  - **`Do_not_disturb`**: sends command to Bluetooth module, suppresses display if in silent mode, still responds to PIR events by showing “Do not disturb!” for 5 seconds. Keys 1/2/3 exit the mode.
  - **Face operation states** (`FACE_VERIFYING`, `FACE_VERIFY_SUCCESS`, `FACE_VERIFY_FAIL`, `FACE_ENROLL_SUCCESS`, `FACE_ENROLL_FAIL`, `FACE_DELETE_SUCCESS`, `FACE_DELETE_FAIL`): display appropriate messages, manage progress bars, and return to menu or idle on completion/failure.
  - **Default**: catches any undefined state, shows “System Error”, resets to idle.
- Error handling: if writing to flash or other operations fail, the state machine moves to the appropriate fail state (e.g., `FACE_ENROLL_FAIL`). Unknown states fall back to idle with a warning.

#### 2. Key scanning and event queue
- Three physical buttons (indices 0–2) map to numeric event codes:
  - **Short presses** return codes `1`, `2`, `3`.
  - **Long presses** (≥ 1500 ms) return `11`, `12`, `13`.
- `Get_key_Num()` runs a non-blocking finite-state machine per button to debounce and detect long presses:
  - Stages: `IDLE` → `BOUNCE_PRESS` → `PRESSED` → (`LONG_REPORTED`) → `BOUNCE_RELEASE` → back to `IDLE`.
  - Only one event is emitted per press to avoid duplication.
- `KeyEvent_Push()` and `Key_GetEvent()` implement a small (16-element) FIFO queue:
  - If an external scanning thread is used, it pushes key codes into the queue.
  - Menu logic always consumes from `Key_GetEvent()`, which pulls from the queue first, otherwise falls back to `Get_key_Num()` when external scanning isn’t active.
  - Queue overflow discards the oldest event to preserve the latest input.
- Side effects inside key scanning include battery status updates (refresh battery icon) and periodic `HC15_SendMessage("AA0055")`, implying the key poller doubles as a general housekeeping routine.

#### 3. Top-level icon menu (`menu1`)
- Presents three icon options:
  1. **Config** (`flag == 1`)
  2. **Else Mode** (`flag == 2`)
  3. **Back** (`flag == 3`)
- Navigation/confirm keys:
  - **Key 1** (short press) moves selection left; wraps from 1 to 3.
  - **Key 3** moves selection right; wraps from 3 to 1.
  - **Key 2** confirms and returns the selected flag.
  - **Key 13** (long press on key 3) activates Do Not Disturb immediately (`silent_do_not_disturb = true`) and exits the menu.
  - **Key 12** (long press on key 2) opens the hidden Door Calibration routine.
- Display logic redraws icons only when the selection changes; always overlays battery status.

#### 4. Configuration workflow (`handle_config_menu`)
- Triggered when `menu1` returns `1`.
- Steps:
  1. Slides in “Radar Config” animation.
  2. Selects `user_id = 1` (currently single-user assumption).
  3. Attempts to load configuration from flash; if missing, loads defaults (`angle=1`, `speed=1`, `auto-close=1`).
  4. Shows the current user ID and config values.
  5. Enters **menu3 (Angle/Speed)** for modification.
- **Menu3 (Angle-Speed-Auto Close)**:
  - Five options navigated by key 1/3:
    1. Cycle door angle among `Small`, `Medium`, `Large`.
    2. Cycle door speed among `Slow`, `Moderate`, `Fast`.
    3. Toggle “Auto Close” between `Yes` and `No`.
    4. **Save** (commits changes, returns 1).
    5. **Exit** (cancel, returns 0).
  - Key 2 applies the change for the highlighted option or confirms save/exit.
  - Changing any option sets a “config changed” flag so the screen refreshes with new values.
  - `debug_change_state` tracks editing stage, presumably for instrumentation.
- Saving details:
  - If user chose Save (`config_result == 1`), the firmware:
    - Displays a “Saving config...” message and progress bar for ~2 seconds.
    - Populates `user_cfg_diy` with the chosen parameters.
    - Erases the entire user data Flash region (`Flash_EraseAllUserData()`), then writes the new configuration at an 8-byte aligned address (`FLASH_USER_BASE_ADDR + user_id * 256`).
    - Adds CRC to detect corruption; verifies by re-loading and comparing fields.
  - Success triggers `FACE_ENROLL_SUCCESS` state; failure sets `FACE_ENROLL_FAIL`.
- Cancelling the menu (Exit without saving) immediately sets `FACE_ENROLL_FAIL` to return to the menu gracefully.

#### 5. Else Mode menu (`handle_else_mode_menu`)
- Triggered when `menu1` returns `2`.
- Presents three text options via `menu2_else_mode_with_return()`:
  1. **Do Not Disturb** – sets `silent_do_not_disturb = true` and `system_state = Do_not_disturb`, clears the display.
  2. **Door Reset** – invokes the hidden calibration handler `handle_Reset_menu()`.
  3. **Back** – returns to the main menu.
- Navigation identical to other vertical menus: key 1 moves up, key 3 moves down, key 2 selects.

#### 6. Door calibration hidden menu (`handle_Reset_menu`)
- Accessed via long press on key 2 in the top-level menu or via Else Mode → Door Reset.
- Procedure:
  1. Sends `HC15_SendMessage("AARE55")` to notify Bluetooth module.
  2. Draws a framed instruction screen prompting user to open the door to the maximum angle and press any key.
  3. Waits for any key event.
  4. Sends `AA0055` to revert the Bluetooth signalling.
  5. Runs a 10-second blocking progress bar (`Flash_ShowBlockingProgress(10000)`) to simulate calibration.
  6. Shows a “Calibration Complete!” screen with a tick mark.
  7. Returns to the top-level menu (screen cleared).

#### 7. Reset/Delete menu (`handle_delete_menu`)
- Triggered when `menu1` returns `3`? (Actually return value 3 is “Back”, which sets system to idle. Delete menu might be invoked elsewhere or via face recognition UI.)
- Uses `menu2_delete_with_return()` to present:
  1. **Reset All**
  2. **Reset Single**
  3. **Back**
- Choosing Reset All sets `Delete = true` and starts the delete process:
  - Shows “Resetting...” message with a progress bar for up to 5 seconds.
  - Calls `FaceRec_ClearAllUsers()` repeatedly and checks `FaceRec_IsDeleteSuccess()` to determine completion.
  - Updates progress bar to 100% when success response is detected.
  - Sets `system_state` to `FACE_DELETE_SUCCESS` or `FACE_DELETE_FAIL`.
- Choosing Reset Single shows “Reset Single – Press any key” but doesn’t yet implement actual single-user deletion logic (placeholder).
- Back returns without changes.

#### 8. Do Not Disturb state logic (`system_state == Do_not_disturb`)
- Entered from:
  - Long press key 3 in menu (`menu1`), which sets the `silent_do_not_disturb` flag.
  - Else Mode → Do Not Disturb.
- Behaviour:
  - Sends `AA0055` command every loop iteration.
  - If LoRa flag is set, sends `AARF55` and clears the flag.
  - Any short press key 1/2/3 exits Do Not Disturb (note: comment says “long press key 3 to exit,” but code triggers on any short press, which might be a mismatch to clarify).
  - When `silent_do_not_disturb` is true, the OLED remains blank.
  - If not silent, a PIR trigger (pin high) causes a timed message “Do not disturb!” to display for 5 seconds before clearing.

#### 9. Power management and idle behaviour
- `SYSTEM_IDLE` tries to reduce power after 2 seconds of inactivity:
  - Sends multiple `AT+DISCONN` commands to XY_MB06BA module (with short delays) to ensure disconnection.
  - Sets specific GPIO pins high/low to power down the door actuator driver (e.g., gating NMOS).
  - Calls `PowerMgmt_SetLowPowerMode(1)` presumably to reduce MCU consumption.
  - Clears the OLED.
- Idle loops continue to clear the display and delay, keeping the device ready to wake (likely through button events or interrupts elsewhere in the system).

---

### Persistence, flash layout, and CRC protection

- Flash address map:
  - **Program code**: 0x08000000–0x0803C000 (240 KB).
  - **User data**: 0x0803C000–0x0803F800 (14 KB) for up to 56 user profiles (256 bytes each).
  - **BLE address**: 0x0803F800–0x08040000 (2 KB), isolated from user data to avoid conflicts.
- `user_config_t` structure (from `Flash.h`):
  - Contains `user_id`, `open_angle`, `open_speed`, `open_or_not_flag`, reserved bytes, and an 8-bit CRC.
- Flash handlers ensure 8-byte alignment when writing (`Flash_Write64BitAligned`), as required by STM32L4 double-word programming.
- Functions:
  - `Flash_LoadUserConfig` reads the block, checks for erased state (all 0xFF), and validates CRC.
  - `Flash_SaveUserConfig` manages page erasure when necessary, logs CRC, and writes aligned data.
  - `Flash_EraseAllUserData` wipes all seven 2KB pages reserved for user configs.
  - `Flash_GetDefaultUserConfig` supplies fallback values.
- BLE-specific functions mirror the approach with `ble_address_storage_t`: store a MAC, validity flag (0x55), and CRC.

---

### Communications and external integrations

- **HC15 Bluetooth module (`bluetooth_comm.h`)**
  - `HC15_SendMessage()` used throughout; sample commands:
    - `AA0055` likely a keep-alive or status request.
    - `AARE55`, `AARI55`, `AARF55` used during calibration, LoRa response, and Do Not Disturb sequences.
- **LoRa integration**
  - `lora_rx_flag` external global triggers responses; when set, the Flash task replies with `AARI55` (in general state) or `AARF55` (Do Not Disturb context).
- **XY_MB06BA module**
  - `XY_MB06BA_SendATCommand("AT+DISCONN=1")`/`("AT+DISCONN=0")` toggled to manage Bluetooth disconnection in idle state; commands are sent twice in quick succession (perhaps for reliability).
- **Face recognition module (`face_recognition.h`)**
  - `FaceRec_ClearAllUsers`, `FaceRec_HasDataAvailable`, `FaceRec_Process`, `FaceRec_IsDeleteSuccess` manage deletion progress.
  - `face_enroll_in_progress` flag indicates when menu interactions relate to enrollment/config.
- **Radar/LiDAR (LD2450)**
  - Not directly manipulated in this excerpt, but configuration is labelled “Radar Config,” implying these values communicate with radar integration via other modules.
- **PIR sensor**
  - Polled via `HAL_GPIO_ReadPin(PIR_INPUT_GPIO_Port, PIR_INPUT_Pin)` to flash Do Not Disturb messages when motion is detected.
- **Battery sensor**
  - `Battery_Update()`/`Battery_GetInfo()` returns a struct with a battery percentage; then draws battery level on the OLED.

---

### Menus and branches summary

- **Main Icon Menu (`menu1`)**
  - Option 1 (Config) → `handle_config_menu()`.
  - Option 2 (Else Mode) → `handle_else_mode_menu()`.
  - Option 3 (Back) → sets `SYSTEM_IDLE` and clears control flag.
  - Long press key 3 anywhere here → Do Not Disturb.
  - Long press key 2 → Hidden Door Calibration.

- **Configuration sub-menu**
  - Angle/Speed screen has five items: Angle, Speed, Auto Close, Save, Exit.
  - Angle cycles: `Small → Medium → Large` (presumably 90°, 120°, 180°).
  - Speed cycles: `Slow → Moderate → Fast`.
  - Auto Close toggles `Yes ↔ No`.
  - Save writes config, progress bar.
  - Exit cancels.

- **Else Mode menu**
  - Choice 1: Do Not Disturb.
  - Choice 2: Door Reset (Calibration).
  - Choice 3: Back.

- **Delete menu (with back)**
  - Choice 1: Reset All (calls face modules to clear all users).
  - Choice 2: Reset Single (UI stub).
  - Choice 3: Back.

---

### Loops, timing, and background tasks

- Most menu loops (`menu1`, `menu2_*`, `menu3_angle_speed`) poll `Key_GetEvent()` in a while-loop, with small `osDelay` calls (5–10 ms) to reduce CPU usage and flicker.
- `Flash_ShowBlockingProgress` uses `HAL_GetTick()` to measure elapsed time, updates the progress bar roughly every 20 ms, and calls `osDelay(5)` inside the loop to yield.
- `Flash_Task` includes `osDelay(1)` at the end of each iteration to avoid monopolizing the CPU.
- Delete process loops while less than timeout, updates progress bar, polls `FaceRec_*` functions, sleeps 5 ms when there is no new data.
- Idle state includes 50 ms delay after clearing display.

---

### Error handling and fallback behaviour

- Flash writes are wrapped with success checks; `save_success` gate ensures user is told “Config Saved” or “Save Failed.” Failures lead to `FACE_ENROLL_FAIL`.
- Flash loads first check for erased state, then run CRC; CRC failure means configuration is treated as absent.
- BLE MAC load/save functions return boolean success, verifying both CRC and validity flag; they also reject all-zero or all-FF addresses.
- On unknown states in the main task, the user sees “System Error” and the system resets to idle.
- `Get_key_Num()` ensures spurious bounces below the debounce threshold produce no key codes.
- Delete process includes a 5-second timeout; if `FaceRec_IsDeleteSuccess()` never returns true, the code exits with `FACE_DELETE_FAIL`.

---

### Assumptions and limitations

- Only one user configuration (`user_id = 1`) is actively used, even though storage supports up to 56. Multi-user selection UI is not implemented.
- Single-phase write: `handle_config_menu` erases the entire user data region before writing the new config. This is safe only if the system stores one record; with multiple users, this would wipe other entries.
- Do Not Disturb exit responds to any short press; comments mention “long press key 3,” so documentation or behaviour should be reconciled.
- `KEY_DEBOUNCE_TIME_MS` is set to zero in the supplied constants—likely adjusted for testing. In production it should be non-zero to remove mechanical bounce.
- Calibration routine is blocking (waits 10 seconds); during that period, other tasks may be delayed.
- Several external references (`lora_rx_flag`, `info`, `face_rec_running`) are not defined here, implying integration with other modules in the project.

---

### Data structures and storage summary

- **User config**
  - Stored per-user (256-byte slot).
  - Fields for door angle (1–3), speed (1–3), auto close flag (1/2).
  - Protected by 8-bit XOR CRC.
  - Flash addresses are forced to 8-byte alignment and require page erase before rewrite.
- **BLE address**
  - Stored separately in a 16-byte structure with MAC (6 bytes), validity flag, reserved padding, and CRC.
  - The code ensures the MAC is neither all zeros nor all 0xFF.
- **DIY frame sender (UART)**
  - `FLASH_SendDIYFrame_UART1` prepares a 7-byte binary frame: `FA CE` header, UID low/high, speed/angle nibble, open flag, CRC8. Currently marked `__attribute__((unused))`.

---

### Practical guidance for cross-functional teams

- **Operations / product**: The UI presented to end users is simple:
  - Three top-level icons: configure door behaviour, enter do-not-disturb or calibration, or exit.
  - Config menu cycles through angle, speed, auto-close; Save is a deliberate choice.
  - Hidden calibration can be triggered intentionally; progress bar communicates when to wait.
  - Delete/reset is accessible (likely via another path) with clear “Reset all vs single” options.
- **Firmware**: If more users must be supported, menu logic for user selection and non-destructive flash writes must be expanded (current erase-all strategy would lose other users).
- **QA**: Testing should cover all state transitions, including timeouts in delete, verifying that flash writes succeed under power-off conditions, and confirming that command strings to HC15/XY modules match integration expectations.
- **DevOps / manufacturing**: BLE MAC can be provisioned through `Flash_SaveBLEAddress`, ensuring CRC integrity. The flash map avoids collision with the main firmware image.
- **UX**: Upgrades should align comments and behaviours (e.g., do-not-disturb exit). Battery icon updates happen within key scanning, so frequent key polling is necessary to keep status fresh.

This walkthrough should arm cross-functional stakeholders with a clear understanding of how the system reacts to user input, manages state, writes persistent settings, and communicates with other modules.