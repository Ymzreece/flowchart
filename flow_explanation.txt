Overview and purpose
This file implements the main control loop for a small embedded system that drives a motorized mechanism (e.g., a smart door/handle or gate) based on sensor feedback, radio commands, and local inputs. It:

- Accepts LoRa and Bluetooth (XY_MB06BA) commands to open, close, and keep the motor power enabled.
- Uses a yaw angle from an IMU to determine how far the mechanism has moved and when to stop.
- Detects stalls, collisions, or wrong-direction motion using yaw dynamics and current sensing.
- Performs an initial calibration/limit procedure (“Auto_Check”) and persists the result in flash.
- Enters a low-power sleep state when idle and wakes on activity.
- Allows manual triggering via a GPIO edge (PB6) and via inferred human push/pull (ahead_flag/back_flag).

High-level flow: inputs to outputs
- Power-up and resume
  - Initialize, stop the motor, read calibration from flash (diff_sumup and check_flag).
  - If calibration exists (check_flag), start in normal mode; otherwise wait for a LoRa frame to trigger Auto_Check calibration.

- Event inputs the task continuously monitors:
  - LoRa frames in lora_rx_buf (lora_rx_flag indicates new data).
  - Bluetooth commands from XY_MB06BA_CheckAndParseCommands().
  - Yaw angle and motion from the IMU (LSM6DSV16X and JY61P).
  - Bus current from Motor_TryReadBusCurrent.
  - Physical push/pull flags (ahead_flag/back_flag) set elsewhere.
  - A local GPIO input (PB6) edge for manual open.
  - An “AA00 power-hold” state driven by periodic LoRa “AA00” messages.

- Decision and control:
  - If calibration not completed (check_flag == false): any LoRa frame triggers Auto_Check to establish limits (diff_sumup) and set check_flag, then normal control begins.
  - If calibrated:
    - Handle AAxx and other LoRa commands:
      - AA00: keep motor power enabled (no movement).
      - AAxy (x=speed level 1–3, y=angle level 1–3): command open with chosen speed and partial angle.
      - AAOF: request closing after opening completes.
      - AARE: request re-calibration (check_flag cleared).
    - Start opening when commanded or when ahead_flag indicates a physical push in the opening direction or when PB6 is toggled.
    - Start closing when commanded or when back_flag indicates pull toward closed or after idle timeout.
    - While moving, compute a speed command from yaw error and clamp it to safety limits; stop when reaching target angle, overshooting, stall is detected, or a switch-over is requested.

- Outputs and side effects:
  - Motor enable pin toggled and drive commands sent via motor_drive_cmd/send_data.
  - Low-power transitions: put IMU and Bluetooth to sleep; set radar threshold and a sleep flag.
  - Persist calibration and radar distance to flash.
  - Reset yaw on full close.

Core concepts and state flags
- check_flag: “System calibrated and ready.” Determines if Auto_Check is needed.
- diff_sumup: Stored maximum opening yaw (angle span) from calibration; used as target.
- motor_runing_flag / motor_runing_flag_r: Opening vs. closing movement in progress.
- commandExecuted / commandExecuted_r: Latched intent to open/close from a radio command.
- ahead_flag / back_flag: External signals meaning the user pushed/pulled the mechanism physically.
- face_control_flag, Speed_Level_Lora, Angle_Level_Lora: Shape a partial opening (“face control”) with adjustable speed and angle.
- closing_inpurrt: A switch-over marker. If a new open command arrives while closing, this forces the close to stop and hand over to open.
- aa00_motor_enabled and last_message_time: Hold motor power on as long as AA00 messages keep arriving or the mechanism is moving.

Main components and how they interact
- Else_Task (FreeRTOS task loop)
  - Initializes, restores calibration, and then loops every 10 ms to:
    - Update bus current telemetry.
    - Parse Bluetooth commands (XY_MB06BA_CheckAndParseCommands).
    - If not calibrated, run Auto_Check when any LoRa frame arrives and store results to flash.
    - If calibrated, parse LoRa AAxx commands and set flags accordingly.
    - Manage idle timeouts to auto-close or enter low power.
    - Run the motion controller for open and for close (two mirrored branches).
    - Check for stalls with Yaw_Stall_Check to protect hardware and users.
    - Maintain AA00 power-hold and shut down power on timeout if not moving.
    - Watch PB6 edges and trigger an open if idle.

- LoRa command parsing (within Else_Task)
  - AA00: Set motor enable pin high and mark aa00_motor_enabled; the task will keep the motor powered while messages arrive or while motion is happening.
  - AAxy: x is speed level, y is angle level.
    - Speed levels: 1→600, 2→1200, 3→2000 (drive command clamp).
    - Angle levels: 1→open to one-third of the calibrated yaw; 2→half; 3→full, unless face_control_flag is off (then always full).
    - Sets flags to start opening immediately and allows interrupting a closing motion.
  - AAOF: After finishing an open, immediately start closing.
  - AARE: Clear check_flag to force a re-calibration mode next time a frame arrives.

- Motion control (open)
  - Entry condition:
    - A command (commandExecuted) or ahead_flag is set, the current yaw is below the target (yaw < diff_sumup), and the gap is meaningful (> 2 deg), or motor_runing_flag already latched.
  - On first entry:
    - Enable motor power, reset timers and current readings, and switch controller to speed mode (send_data(speed_control)).
  - Target angle:
    - Calculate threshold = diff_sumup / angle_divisor (1→/3; 2→/2; 3→/1). If not “face control”, use full diff_sumup.
  - Speed command:
    - speed = Motor_P * (threshold - yaw), clamped to ±Speed_from_Lora; send via motor_drive_cmd.
  - Stop conditions:
    - Near target (|threshold − yaw| < 5 deg) OR near full open (|diff_sumup − yaw| < 5 deg)
    - Yaw exceeded diff_sumup (overshoot) OR Yaw_Stall_Check() signals stall/collision.
  - On stop:
    - Stop motor, drop power, clear flags. If AAOF was set, immediately queue a closing (commandExecuted_r = 1).

- Motion control (close)
  - Entry condition:
    - A command (commandExecuted_r) or back_flag is set and yaw > 0 and |yaw| > 2 deg, or the latched motor_runing_flag_r is set.
  - On first entry:
    - Enable motor power, reset timers/current, switch to speed mode.
  - Target angle:
    - Always 0 degrees (fully closed). The math subtracts (yaw + 3) to add a small bias to ensure firm closure.
  - Speed command:
    - speed = Motor_P * (0 − (yaw + 3)), clamped to ±Speed_from_Lora; send via motor_drive_cmd.
  - Stop conditions:
    - Near closed (|yaw| < 5 deg) OR stall detected (Yaw_Stall_Check()) OR undershoot (yaw < 0) OR a new open command arrived mid-close (closing_inpurrt == 1).
  - On stop:
    - If it was a clean close (no collision and not interrupted), briefly back-drive to snug fit, stop, power down, put peripherals to sleep, save radar threshold, and reset yaw to zero.
    - If interrupted by a new open command, hand over to opening (set motor_runing_flag = 1).

- Stall and safety detection: Yaw_Stall_Check
  - Begins checking 1.5 s after motion start to avoid startup transients.
  - Three safety checks:
    - Wrong-direction motion: during opening, |yaw| should increase; during closing, |yaw| should decrease. A violation triggers an immediate stop.
    - Oscillation: repeated sign changes in yaw increments indicate oscillation; more than two reversals triggers a stop.
    - Insufficient progress: if yaw changes by less than a small threshold for 1.5 s, treat as stalled and stop.
  - Note: Some numeric thresholds in comments and code differ; see “Assumptions and limitations.”

- Low-power management
  - If idle > 15 s:
    - If near closed (|yaw| < 10 deg), put the system to sleep:
      - Disable motor power.
      - Put Bluetooth and IMU to sleep, toggle power control GPIOs.
      - Save radar threshold (FRadar_SetDistanceAndSave) and set LowPower_SetSleepFlag(1).
    - Else (door is not near closed), schedule an automatic close by setting motor_runing_flag_r = 1.

- AA00 power-hold window
  - While aa00_motor_enabled:
    - If the mechanism is moving, keep refreshing the timeout.
    - If not moving and the timeout elapses, drop motor power and clear the flag.
  - Important: The constant MESSAGE_TIMEOUT_MS is set to 100, but comments say “10 seconds.” Confirm and correct this value; otherwise the motor may power off after only ~100 ms without messages.

- Manual trigger via PB6
  - Debounced edge detection on GPIOB pin 6 using GPIO_CheckEdge.
  - If idle (no opening/closing active), any edge triggers an open (motor_runing_flag = 1).

Branches, loops, and error handling
- Main loop: runs forever, every 10 ms.
- Two symmetric motion branches: opening and closing; both:
  - Guard entry with multiple flags/sensors.
  - One-time initialization blocks to enable power and set speed mode.
  - Compute a speed command proportional to yaw error and clamp it.
  - Multiple stop conditions including geometric thresholds, overshoot/undershoot, and stall detection.
  - Reset and cleanup blocks that clear state, drop power, and optionally enter low-power sleep.
- Switch-over logic: closing_inpurrt allows a new open command to preempt a closing motion seamlessly.
- Error/stall handling: Yaw_Stall_Check signals wrong direction, oscillation, or no-progress; on detection, motion is stopped and the detection state is reset for the next move.
- Idle and sleep handling: a 15 s watchdog drives either low-power sleep or auto-close, depending on current yaw.

External integrations
- LoRa interface
  - lora_rx_buf, lora_rx_flag are assumed to be maintained by an interrupt/driver elsewhere.
  - Commands used here:
    - AA00: power-hold (supply enable only).
    - AAxy: speed and angle levels for opening.
    - AAOF: request to close after opening.
    - AARE: re-enable calibration mode.
- Bluetooth (XY_MB06BA)
  - XY_MB06BA_CheckAndParseCommands() to receive commands.
  - XY_MB06BA_SendATCommand("AT+DISCONN=x") used to manage connections around sleep.
- IMU and yaw
  - LSM6DSV16X_Handle imu_handle used for sleep control (LSM6DSV16X_AllSleep).
  - JY61P yaw sensor controlled via UART routines (JY61P_UART_Enter_Sleep, JY61P_UART_Reset_Yaw).
  - Yaw variables (yaw, yaw_zero, yaw_offset, etc.) are provided by another module; yaw is used as the sole motion feedback.
- Motor driver
  - motor_drive_cmd sends speed commands; send_data(speed_control) configures speed-close-loop mode.
  - rpm0_Stop stops the motor; bus current is sampled by Motor_TryReadBusCurrent.
  - Motor_SetBusCurrentSlot(2) selects a measurement channel.
- Radar/proximity
  - FRadar_SetDistanceAndSave(&s_fradar, 512) sets and persists a distance threshold before sleep.
- Flash storage
  - Flash_Storage_Init/Read/Write used to persist calibration results (diff_sumup and check_flag).
  - gyro_calib_storage.h is included; gyro calibration is likely handled elsewhere.
- Low power
  - LowPower_SetSleepFlag(1) marks the system for sleep; GPIOA pins 8 and 4, plus the motor enable pin, are toggled to manage supplies.

Data and persistence
- Calibration
  - diff_sumup: the calibrated maximum yaw range considered “full open.”
  - check_flag: whether calibration completed successfully.
  - Both values are restored on boot and likely updated by Auto_Check (invoked elsewhere) and saved by flash_storage.
- Runtime telemetry
  - Current (current_raw, g_motor_bus_current_A) is read and available for diagnostics; a current-based stall trip is present but currently commented out.
- Configuration levels via LoRa
  - Speed levels map to clamped command magnitudes.
  - Angle levels scale the open target for partial opening.

Assumptions and limitations to be aware of
- Timing constants and comments mismatch:
  - MESSAGE_TIMEOUT_MS is 100 in code but commented as “10s.” Decide on the desired behavior and adjust the constant or comment accordingly.
  - Yaw_Stall_Check comments mention “1 second / 3 degrees,” but code uses 1.5 seconds and 0.1 degrees. Align thresholds to actual requirements and update comments.
- Yaw sign conventions:
  - Opening expects yaw to increase; closing expects it to decrease toward zero. If IMU orientation changes, this logic must be adjusted.
- Globals and cross-module state:
  - Many flags and variables are extern (ahead_flag, back_flag, yaw, diff_sumup, Wake_time). Ensure they are updated atomically and consistently across tasks/ISRs.
- Safety and robustness:
  - Collision detection is based purely on yaw dynamics; the current-based trip is commented out. If hardware allows, re-enable or parameterize current-based protection.
  - Magic numbers (Motor_P=40, angular thresholds 5 deg, bias +3 deg) may need tuning per mechanism.
- Power management:
  - Sleep/wake sequences toggle GPIOs and disconnect/reconnect BLE; confirm the order is correct for your board to avoid brownouts or lockups.
- AAxx command parsing:
  - Only ASCII digits ‘1’–‘3’ are accepted for speed/angle. ‘OF’ and ‘RE’ are special strings. Unexpected values are mostly ignored; consider adding explicit rejection/ACKs.

User-visible scenarios
- Open partially with LoRa
  - Send AA21 (speed level 2, angle level 1).
  - The motor powers on, switches to speed mode, and opens to one-third of the calibrated angle at moderate speed. It stops near the target or on stall.
  - If AAOF was also sent earlier, it will close after opening completes.

- Keep motor powered with AA00
  - Periodically send AA00 to keep the motor power enabled while no movement is commanded. If messages stop beyond the timeout, power is removed.

- Recalibration (Auto_Check)
  - Send AARE to clear calibration. On the next LoRa frame arrival, Auto_Check runs, finds limits, sets check_flag, and persists diff_sumup. Normal control resumes thereafter.

- Manual or physical interaction
  - A PB6 press toggles an open if idle.
  - If someone pushes/pulls the mechanism (ahead_flag/back_flag asserted), the system starts opening/closing accordingly.

- Idle timeout
  - If no activity for 15 seconds:
    - If nearly closed, the system sleeps (BLE and IMU go to sleep, radar threshold saved).
    - If not closed, it initiates an automatic close.

Summary of state transitions
- Idle (powered) → Opening
  - Trigger: LoRa AAxy, ahead_flag, PB6 edge, or a closing preempted by a new open.
- Opening → Open stop
  - Trigger: near target, overshoot, or stall detection.
  - Optional transition to Closing if AAOF had been requested.
- Idle (powered) → Closing
  - Trigger: LoRa close intent, back_flag, or idle > 15 s while not near closed.
- Closing → Closed stop
  - Trigger: near zero yaw, undershoot, or stall.
  - If clean close and not interrupted: snug fit, power down, and possibly sleep.
- Any Motion → Preempted/open
  - Trigger: New open command during closing (closing_inpurrt).

This explanation should give non-developers and cross-functional stakeholders a clear picture of how commands, sensors, and control logic combine to move the mechanism safely, when it sleeps, and how it recovers and persists calibration.