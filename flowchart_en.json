{
  "metadata": {
    "title": "State-machine flow for FreeRTOS motion-control loop",
    "summary": "Flowchart of boot calibration, calibrated idle loop, LoRa/Bluetooth command handling, opening/closing control, stall detection, and power management.",
    "language": "en"
  },
  "entry_node": "start",
  "nodes": [
    {
      "id": "start",
      "title": "Start and system boot",
      "summary": "System boots and begins initialization and calibration persistence.",
      "detail": null,
      "type": "start"
    },
    {
      "id": "boot_init",
      "title": "Init Flash and restore calibration",
      "summary": "Initialize Flash storage and read last-known calibration: diff_sumup and check_flag.",
      "detail": "If check_flag is true, calibration is considered complete; otherwise uncalibrated path will be taken.",
      "type": "process"
    },
    {
      "id": "calibrated_at_boot?",
      "title": "Calibrated at boot?",
      "summary": "Decision: is calibration complete (check_flag == true)?",
      "detail": "If calibrated, start in idle; if not, enter uncalibrated path.",
      "type": "decision"
    },
    {
      "id": "uncalibrated_loop",
      "title": "Uncalibrated: wait for LoRa Auto_Check",
      "summary": "Await a LoRa frame to start Auto_Check calibration/limits.",
      "detail": "Auto_Check will set check_flag to true on success.",
      "type": "process"
    },
    {
      "id": "auto_check",
      "title": "Auto_Check (calibration/limit procedure)",
      "summary": "Run calibration to determine diff_sumup and limits; set check_flag on success.",
      "detail": "Diff_sumup becomes total open angle; check_flag becomes true.",
      "type": "call"
    },
    {
      "id": "calibrated_idle",
      "title": "Calibrated Idle",
      "summary": "Calibration complete; monitor for idle, motion commands, and keep-power.",
      "detail": "Main runtime state when calibrated.",
      "type": "process"
    },
    {
      "id": "idle_timeout?",
      "title": "Idle timeout check",
      "summary": "If idle beyond 15s, check yaw to decide low power or force close.",
      "detail": "If |yaw| < 10 deg, enter low-power; else force closing.",
      "type": "decision"
    },
    {
      "id": "low_power_seq",
      "title": "Enter low-power sequence",
      "summary": "Power down motor, peripherals, and sleep subsystems to save power.",
      "detail": "Includes BLE disconnect, IMU sleep, radar save, and yaw reset wait.",
      "type": "process"
    },
    {
      "id": "force_close_idle",
      "title": "Force closing due to idle",
      "summary": "Set motor_runing_flag_r to 1 to begin closing due to long idle without near-zero yaw.",
      "detail": "Opens a closing motion path.",
      "type": "process"
    },
    {
      "id": "lora_parser",
      "title": "LoRa command parser (AA..)",
      "summary": "Parse LoRa frames for control commands.",
      "detail": "AA00 keeps power; AAxy sets speed/angle; AAOF requests close after open; AARE re-enters calibration.",
      "type": "io"
    },
    {
      "id": "aa00_power_on",
      "title": "AA00: keep motor power on",
      "summary": "Turn motor power on and set aa00_motor_enabled.",
      "detail": null,
      "type": "process"
    },
    {
      "id": "aaxy_command",
      "title": "AAxy: set motion/target",
      "summary": "Set Speed_Level_Lora and Angle_Level_Lora; start opening.",
      "detail": "Also asserts flags to begin opening and prepares for timed motion.",
      "type": "process"
    },
    {
      "id": "aaof_command",
      "title": "AAOF: request close after open",
      "summary": "Set close_flag so that closing occurs after an open cycle finishes.",
      "detail": null,
      "type": "process"
    },
    {
      "id": "aare_command",
      "title": "AARE: re-enter calibration",
      "summary": "Reset check_flag to force uncalibrated path on next loop.",
      "detail": null,
      "type": "process"
    },
    {
      "id": "pb6_trigger",
      "title": "PB6 manual trigger",
      "summary": "Detect edge on PB6 to start opening if no motion is active.",
      "detail": "Debounced edge increments a small counter and triggers opening when ready.",
      "type": "io"
    },
    {
      "id": "opening_entry",
      "title": "Opening: entry condition",
      "summary": "Determine if opening should start based on commands/triggers.",
      "detail": "Conditions include commandExecuted, ahead_flag, or motor_runing_flag being set.",
      "type": "decision"
    },
    {
      "id": "opening_init",
      "title": "Opening Init",
      "summary": "Power on, reset accumulators, and enable speed-control for opening.",
      "detail": null,
      "type": "process"
    },
    {
      "id": "opening_control",
      "title": "Opening Control (motion loop)",
      "summary": "Compute speed from yaw error and send motor drive commands.",
      "detail": "Looping control using threshold, yaw, and speed limits.",
      "type": "loop"
    },
    {
      "id": "opening_stop?",
      "title": "Opening Stop condition",
      "summary": "Check if target reached, near threshold, or stall detected.",
      "detail": "If stop, handle stop actions; else continue motion loop.",
      "type": "decision"
    },
    {
      "id": "opening_stop_action",
      "title": "Opening Stop Actions",
      "summary": "Stop RPM, power down, clear flags; possibly queue closing.",
      "detail": "If close_flag is set, prepare closing path.",
      "type": "process"
    },
    {
      "id": "closing_entry",
      "title": "Closing: entry condition",
      "summary": "Determine if closing should start (close command or pull assist).",
      "detail": "Requires yaw to be away from zero and motion flags.",
      "type": "decision"
    },
    {
      "id": "closing_init",
      "title": "Closing Init",
      "summary": "Power on, reset, enable speed-control for closing.",
      "detail": null,
      "type": "process"
    },
    {
      "id": "closing_control",
      "title": "Closing Control (motion loop)",
      "summary": "Drive toward zero angle; bias toward closing; cap speed.",
      "detail": null,
      "type": "loop"
    },
    {
      "id": "closing_stop?",
      "title": "Closing Stop condition",
      "summary": "Check near-zero yaw, overshoot, stall, or preemption by opening.",
      "detail": "If stop, perform post-stop actions; else continue loop.",
      "type": "decision"
    },
    {
      "id": "closing_stop_action",
      "title": "Closing Stop Actions",
      "summary": "Handle post-close behavior, possible low-power sequence.",
      "detail": null,
      "type": "process"
    },
    {
      "id": "yaw_stall_opening",
      "title": "Yaw Stall Check (Opening)",
      "summary": "Detect stall or wrong-direction movement during opening.",
      "detail": "Used to stop safely if stall is detected.",
      "type": "decision"
    },
    {
      "id": "yaw_stall_closing",
      "title": "Yaw Stall Check (Closing)",
      "summary": "Detect stall or collision during closing.",
      "detail": "Used to stop safely and handle errors.",
      "type": "decision"
    },
    {
      "id": "post_move_low_power",
      "title": "Post-move Low-Power Entry",
      "summary": "Apply low-power sequence after a move completes.",
      "detail": null,
      "type": "process"
    },
    {
      "id": "end",
      "title": "End of flow",
      "summary": "End node; represents completion of the modeled sequences.",
      "detail": null,
      "type": "end"
    }
  ],
  "edges": [
    {
      "source": "start",
      "target": "boot_init",
      "label": "boot"
    },
    {
      "source": "boot_init",
      "target": "calibrated_at_boot?",
      "label": "read and restore calibration (diff_sumup, check_flag)"
    },
    {
      "source": "calibrated_at_boot?",
      "target": "calibrated_idle",
      "label": "check_flag == true"
    },
    {
      "source": "calibrated_at_boot?",
      "target": "uncalibrated_loop",
      "label": "check_flag == false"
    },
    {
      "source": "uncalibrated_loop",
      "target": "auto_check",
      "label": "lora_rx_flag == 1"
    },
    {
      "source": "auto_check",
      "target": "calibrated_at_boot?",
      "label": "success / check_flag == true"
    },
    {
      "source": "calibrated_idle",
      "target": "idle_timeout?",
      "label": "every loop cycle"
    },
    {
      "source": "idle_timeout?",
      "target": "low_power_seq",
      "label": "Idle timeout and |yaw| < 10 deg"
    },
    {
      "source": "idle_timeout?",
      "target": "force_close_idle",
      "label": "Idle timeout and |yaw| >= 10 deg"
    },
    {
      "source": "low_power_seq",
      "target": "calibrated_idle",
      "label": "complete low-power wake/sleep"
    },
    {
      "source": "force_close_idle",
      "target": "opening_entry",
      "label": "begin closing by idle preemption"
    },
    {
      "source": "calibrated_idle",
      "target": "lora_parser",
      "label": "loop iteration: poll inputs"
    },
    {
      "source": "lora_parser",
      "target": "aa00_power_on",
      "label": "AA00"
    },
    {
      "source": "lora_parser",
      "target": "aaxy_command",
      "label": "AAxy"
    },
    {
      "source": "lora_parser",
      "target": "aaof_command",
      "label": "AAOF"
    },
    {
      "source": "lora_parser",
      "target": "aare_command",
      "label": "AARE"
    },
    {
      "source": "aa00_power_on",
      "target": "calibrated_idle",
      "label": "return to idle after power-on"
    },
    {
      "source": "aaxy_command",
      "target": "opening_entry",
      "label": "start opening (commandExecuted)"
    },
    {
      "source": "aaof_command",
      "target": "closing_entry",
      "label": "set close_flag"
    },
    {
      "source": "aare_command",
      "target": "uncalibrated_loop",
      "label": "re-enter calibration"
    },
    {
      "source": "pb6_trigger",
      "target": "opening_entry",
      "label": "PB6 edge detected and idle cleared"
    },
    {
      "source": "opening_entry",
      "target": "opening_init",
      "label": "entry condition met"
    },
    {
      "source": "opening_init",
      "target": "opening_control",
      "label": "initialize opening motion"
    },
    {
      "source": "opening_control",
      "target": "yaw_stall_opening",
      "label": "per control cycle"
    },
    {
      "source": "yaw_stall_opening",
      "target": "opening_stop_action",
      "label": "stall detected"
    },
    {
      "source": "yaw_stall_opening",
      "target": "opening_control",
      "label": "no stall"
    },
    {
      "source": "opening_stop_action",
      "target": "closing_entry",
      "label": "close_flag == true"
    },
    {
      "source": "opening_stop_action",
      "target": "post_move_low_power",
      "label": "no close_flag; enter low-power after open"
    },
    {
      "source": "closing_entry",
      "target": "closing_init",
      "label": "entry condition met"
    },
    {
      "source": "closing_init",
      "target": "closing_control",
      "label": "initialize closing motion"
    },
    {
      "source": "closing_control",
      "target": "yaw_stall_closing",
      "label": "per control cycle"
    },
    {
      "source": "yaw_stall_closing",
      "target": "closing_stop_action",
      "label": "stall detected"
    },
    {
      "source": "yaw_stall_closing",
      "target": "closing_control",
      "label": "no stall"
    },
    {
      "source": "closing_stop_action",
      "target": "post_move_low_power",
      "label": "normal stop; enter low-power"
    },
    {
      "source": "yaw_stall_opening",
      "target": "opening_stop_action",
      "label": "emergency stop due to stall"
    },
    {
      "source": "post_move_low_power",
      "target": "calibrated_idle",
      "label": "low-power sequence complete; return to idle"
    },
    {
      "source": "start",
      "target": "end",
      "label": "end of modeled sequence"
    }
  ]
}