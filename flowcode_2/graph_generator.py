from __future__ import annotations

import argparse
import json
import os
from pathlib import Path
from typing import Optional

try:
    from openai import OpenAI
except ImportError as exc:  # pragma: no cover - dependency missing at runtime
    raise SystemExit("Missing dependency 'openai'. Install it with `pip install openai`.") from exc


DEFAULT_MODEL = "gpt-5-nano"


GRAPH_SYSTEM_PROMPT_EN = """You are a senior software architect converting prose explanations into a structured flowchart graph.
Given a detailed natural-language walkthrough of a system, extract every major step, branch, loop, and background activity into nodes and edges that describe control flow.
All textual descriptions must be in English and understandable to non-developers."""

GRAPH_OUTPUT_INSTRUCTION_EN = """
Return ONLY JSON matching this schema:
{
  "metadata": {
    "title": "Concise title",
    "summary": "1-2 sentence overview",
    "language": "en"
  },
  "entry_node": "node id",
  "nodes": [
    {
      "id": "unique string id",
      "title": "Short descriptive title",
      "summary": "One-sentence description of this step",
      "detail": "Optional longer explanation (can be null)",
      "type": "start|process|decision|loop|end|io|call"
    }
  ],
  "edges": [
    {
      "source": "node id",
      "target": "node id",
      "label": "Condition, choice, or trigger leading to this transition (optional)"
    }
  ]
}
Guidelines:
- Include start and end nodes where appropriate.
- Capture each branch or menu option as its own node and label edges with the condition/key press triggering the transition.
- Represent loops explicitly with nodes of type `loop` and show how they iterate and exit.
- Ensure the graph is connected from the entry node and all IDs remain consistent.
- Do not wrap the JSON in code fences or add commentary.
"""

TRANSLATION_SYSTEM_PROMPT_ZH = """You are a meticulous technical translator.
Preserve the structure of a flowchart JSON object while translating every human-readable string into Simplified Chinese.
Keep IDs, node types, and all structural fields exactly the same."""

TRANSLATION_INSTRUCTION_ZH = """
You will receive a flowchart JSON object in English. Return the same JSON structure, but translate these fields into Simplified Chinese:
- metadata.title, metadata.summary (set metadata.language to "zh")
- nodes[].title, nodes[].summary, nodes[].detail
- edges[].label
Do not alter IDs, node types, or add/remove fields. Return only JSON without code fences.
"""


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Convert a natural-language explanation into bilingual flowchart JSON (English and Chinese)."
    )
    parser.add_argument(
        "--input",
        type=Path,
        default=Path("../flow_explanation.txt"),
        help="Path to the explanation text generated by flowcode_1 (default: ../flow_explanation.txt).",
    )
    parser.add_argument(
        "--output-prefix",
        "--output",
        dest="output_prefix",
        type=Path,
        default=Path("flowchart"),
        help="Base name for generated files (default: flowchart â†’ flowchart_en.json & flowchart_zh.json).",
    )
    parser.add_argument(
        "--model",
        type=str,
        default=DEFAULT_MODEL,
        help=f"LLM model to use (default: {DEFAULT_MODEL}).",
    )
    parser.add_argument(
        "--show-prompt",
        action="store_true",
        help="Print prompts before they are sent to the model.",
    )
    return parser


def read_text(path: Path) -> str:
    try:
        return path.read_text(encoding="utf-8")
    except FileNotFoundError:
        raise SystemExit(f"Input file not found: {path}")


def write_json(path: Path, payload: dict) -> None:
    path.write_text(json.dumps(payload, indent=2, ensure_ascii=False), encoding="utf-8")
    print(f"Wrote flowchart JSON to {path}")


def call_model(prompt: str, instructions: str, *, model: str, show_prompt: bool) -> str:
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise SystemExit(
            "Environment variable OPENAI_API_KEY is not set. "
            "Export your API key before running this script."
        )

    client = OpenAI(api_key=api_key)

    if show_prompt:
        print("--- Prompt being sent ---")
        print(prompt)
        print("--------------------------")

    response = client.responses.create(
        model=model,
        instructions=instructions,
        input=prompt,
    )

    if hasattr(response, "output_text"):
        return response.output_text  # type: ignore[attr-defined]

    try:
        return response.output[0].content[0].text  # type: ignore[attr-defined]
    except (AttributeError, IndexError, KeyError) as exc:  # pragma: no cover
        raise SystemExit(f"Unexpected API response format: {response}") from exc


def generate_english_graph(explanation: str, *, model: str, show_prompt: bool) -> dict:
    prompt = f"{explanation}\n\n{GRAPH_OUTPUT_INSTRUCTION_EN.strip()}"
    raw = call_model(prompt, GRAPH_SYSTEM_PROMPT_EN, model=model, show_prompt=show_prompt)
    try:
        data = json.loads(raw)
    except json.JSONDecodeError as exc:
        raise SystemExit(f"English graph generation failed: {exc}\nRaw output:\n{raw}") from exc

    if isinstance(data, dict):
        metadata = data.setdefault("metadata", {})
        metadata["language"] = "en"
    return data


def translate_graph_to_chinese(english_graph: dict, *, model: str, show_prompt: bool) -> dict:
    english_json = json.dumps(english_graph, ensure_ascii=False, indent=2)
    prompt = f"Here is a flowchart JSON object in English:\n{english_json}\n\n{TRANSLATION_INSTRUCTION_ZH.strip()}"
    raw = call_model(prompt, TRANSLATION_SYSTEM_PROMPT_ZH, model=model, show_prompt=show_prompt)
    try:
        data = json.loads(raw)
    except json.JSONDecodeError as exc:
        raise SystemExit(f"Chinese translation failed: {exc}\nRaw output:\n{raw}") from exc

    if isinstance(data, dict):
        metadata = data.setdefault("metadata", {})
        metadata["language"] = "zh"
    return data


def main(argv: Optional[list[str]] = None) -> None:
    parser = build_parser()
    args = parser.parse_args(argv)

    explanation = read_text(args.input)
    if not explanation.strip():
        raise SystemExit(f"Input file {args.input} is empty.")

    prefix_path = args.output_prefix
    parent = prefix_path.parent
    stem = prefix_path.stem if prefix_path.suffix else prefix_path.name
    english_path = parent / f"{stem}_en.json"
    chinese_path = parent / f"{stem}_zh.json"

    print(f"Using model: {args.model}")
    print(f"Reading explanation from: {args.input}")

    english_graph = generate_english_graph(explanation, model=args.model, show_prompt=args.show_prompt)
    write_json(english_path, english_graph)

    chinese_graph = translate_graph_to_chinese(english_graph, model=args.model, show_prompt=args.show_prompt)
    write_json(chinese_path, chinese_graph)


if __name__ == "__main__":  # pragma: no cover
    main()
